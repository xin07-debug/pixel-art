<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>视频转 GIF/精灵图工具 (支持透明/抠图)</title>
    <!-- 引入 Tailwind CSS (样式) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 React 和 ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- 引入 Babel (让浏览器能运行 React 代码) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- 引入 gif.js (核心库) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    
    <style>
        /* 自定义滚动条样式 */
        .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1f2937; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        /* 隐藏视频但保持渲染 */
        .video-hidden { 
            position: absolute;
            top: -9999px;
            left: -9999px;
            opacity: 0;
            pointer-events: none;
            width: 320px; 
            height: 240px;
        }
        
        /* 颜色选择器样式优化 */
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 32px;
            height: 32px;
            padding: 0;
            overflow: hidden;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: 2px solid #4b5563;
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // 图标组件
        const FilmIcon = ({className}) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M7 3v18"/><path d="M3 7.5h4"/><path d="M3 12h18"/><path d="M3 16.5h4"/><path d="M17 3v18"/><path d="M17 7.5h4"/><path d="M17 16.5h4"/></svg>;
        const UploadIcon = ({className}) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>;
        const SettingsIcon = ({className}) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
        const ImageIcon = ({className}) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>;
        const DownloadIcon = ({className}) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>;
        const AlertCircleIcon = ({className}) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></svg>;
        const WandIcon = ({className}) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M15 4V2"/><path d="M15 16v-2"/><path d="M8 9h2"/><path d="M20 9h2"/><path d="M17.8 11.8 19 13"/><path d="M15 9h0"/><path d="M17.8 6.2 19 5"/><path d="m3 21 9-9"/><path d="M12.2 6.2 11 5"/></svg>;
        const GridIcon = ({className}) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>;
        const ShieldIcon = ({className}) => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>;

        const App = () => {
          const [videoUrl, setVideoUrl] = useState(null);
          const [videoMeta, setVideoMeta] = useState({ duration: 0, width: 0, height: 0 });
          
          // 配置参数
          const [outputMode, setOutputMode] = useState('sprite'); // 'sprite' | 'gif'
          const [frameCount, setFrameCount] = useState(12);
          const [scale, setScale] = useState(0.25);
          const [columns, setColumns] = useState(4);
          
          // 抠图参数
          const [removeBg, setRemoveBg] = useState(false);
          const [keyColor, setKeyColor] = useState('#00ff00'); // 默认绿色
          const [enableSecondColor, setEnableSecondColor] = useState(false); // 是否启用第二种颜色
          const [keyColor2, setKeyColor2] = useState('#cccccc'); // 默认灰色
          const [tolerance, setTolerance] = useState(60); // 容差
          const [protectBody, setProtectBody] = useState(false); // 新增：保护人物内部
          
          // 状态
          const [isProcessing, setIsProcessing] = useState(false);
          const [progress, setProgress] = useState(0);
          const [generatedImage, setGeneratedImage] = useState(null);
          const [error, setError] = useState(null);

          const videoRef = useRef(null);
          const canvasRef = useRef(null);
          const fileInputRef = useRef(null);

          // 当帧数改变时，自动调整列数
          useEffect(() => {
            if (frameCount > 0 && outputMode === 'sprite') {
              setColumns(Math.ceil(Math.sqrt(frameCount)));
            }
          }, [frameCount, outputMode]);

          const handleFileChange = (event) => {
            const file = event.target.files[0];
            if (file) {
              if (videoUrl) URL.revokeObjectURL(videoUrl);
              const url = URL.createObjectURL(file);
              setVideoUrl(url);
              setGeneratedImage(null);
              setError(null);
              setProgress(0);
            }
          };

          const handleLoadedMetadata = () => {
            if (videoRef.current) {
              setVideoMeta({
                duration: videoRef.current.duration,
                width: videoRef.current.videoWidth,
                height: videoRef.current.videoHeight,
              });
            }
          };

          const hexToRgb = (hex) => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
              r: parseInt(result[1], 16),
              g: parseInt(result[2], 16),
              b: parseInt(result[3], 16)
            } : null;
          };

          // 核心抠图算法 - 支持双色 & 连通域保护
          const applyChromaKey = (ctx, width, height, colors, tolerance, protectBody) => {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            const targets = colors.map(c => hexToRgb(c)).filter(Boolean);
            if (targets.length === 0) return;

            const toleranceSq = tolerance * tolerance;

            // 颜色匹配判断
            const isMatch = (r, g, b) => {
                for (let t of targets) {
                    const distSq = (r - t.r) ** 2 + (g - t.g) ** 2 + (b - t.b) ** 2;
                    if (distSq < toleranceSq) return true;
                }
                return false;
            };

            if (!protectBody) {
                // 原有逻辑：全局替换 (如果不开启保护)
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i+3] === 0) continue;
                    if (isMatch(data[i], data[i+1], data[i+2])) {
                        data[i + 3] = 0; 
                    }
                }
            } else {
                // 新逻辑：从边缘泛洪 (Flood Fill) 保护内部
                const stack = []; 
                const getIndex = (x, y) => (y * width + x) * 4;

                // 检查并推入栈
                const checkAndPush = (x, y) => {
                    const idx = getIndex(x, y);
                    // 只有未处理过(非透明)且匹配颜色的才加入
                    if (data[idx+3] !== 0 && isMatch(data[idx], data[idx+1], data[idx+2])) {
                        stack.push([x, y]);
                        data[idx+3] = 0; // 立即标记为透明（已访问）
                    }
                };

                // 1. 扫描四周边框作为种子点
                // 上下边
                for (let x = 0; x < width; x++) {
                    checkAndPush(x, 0);
                    checkAndPush(x, height - 1);
                }
                // 左右边
                for (let y = 1; y < height - 1; y++) {
                    checkAndPush(0, y);
                    checkAndPush(width - 1, y);
                }

                // 2. 广度优先搜索 (消除连通的背景)
                while (stack.length > 0) {
                    const [cx, cy] = stack.pop();
                    
                    // 4邻域
                    const neighbors = [
                        [cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]
                    ];

                    for (let [nx, ny] of neighbors) {
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const nIdx = getIndex(nx, ny);
                            // 如果邻居也是目标色且没被消除
                            if (data[nIdx+3] !== 0 && isMatch(data[nIdx], data[nIdx+1], data[nIdx+2])) {
                                data[nIdx+3] = 0; // 消除
                                stack.push([nx, ny]);
                            }
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
          };

          const seekToTime = (videoElement, time) => {
            return new Promise((resolve) => {
              const timeoutId = setTimeout(() => {
                  console.warn("Seek timeout, forcing next frame");
                  resolve();
              }, 3000);

              const onSeeked = () => {
                clearTimeout(timeoutId);
                videoElement.removeEventListener('seeked', onSeeked);
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        resolve();
                    });
                });
              };
              videoElement.addEventListener('seeked', onSeeked);
              videoElement.currentTime = time;
            });
          };

          const applyCheckerboardPreset = () => {
              setKeyColor('#ffffff'); // 白色
              setKeyColor2('#cccccc'); // 常见棋盘格灰色
              setEnableSecondColor(true);
              setTolerance(50); 
              setRemoveBg(true);
              // 自动开启人物保护，因为棋盘格双色极易误伤人物
              setProtectBody(true);
          };

          // 核心生成逻辑
          const generate = async () => {
            if (!videoRef.current || !canvasRef.current) return;

            setIsProcessing(true);
            setProgress(0);
            setError(null);
            setGeneratedImage(null);

            try {
              const video = videoRef.current;
              const canvas = canvasRef.current;
              const ctx = canvas.getContext('2d', { willReadFrequently: true });

              const totalFrames = parseInt(frameCount);
              const frameWidth = Math.floor(videoMeta.width * scale);
              const frameHeight = Math.floor(videoMeta.height * scale);

              let gif = null;
              if (outputMode === 'gif') {
                  try {
                      const workerBlob = await fetch('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.worker.js').then(r => r.blob());
                      const workerUrl = URL.createObjectURL(workerBlob);
                      
                      gif = new GIF({
                          workers: 2,
                          quality: 10,
                          width: frameWidth,
                          height: frameHeight,
                          workerScript: workerUrl,
                      });
                  } catch (e) {
                      throw new Error("初始化 GIF 组件失败，请检查网络连接（需要访问 CDN）。");
                  }
              }

              if (outputMode === 'sprite') {
                  const cols = parseInt(columns);
                  const rows = Math.ceil(totalFrames / cols);
                  canvas.width = cols * frameWidth;
                  canvas.height = rows * frameHeight;
              } else {
                  canvas.width = frameWidth;
                  canvas.height = frameHeight;
              }

              ctx.clearRect(0, 0, canvas.width, canvas.height);
              
              const interval = videoMeta.duration / (totalFrames + 1);
              const delay = (interval * 1000); 

              const tempCanvas = document.createElement('canvas');
              tempCanvas.width = frameWidth;
              tempCanvas.height = frameHeight;
              const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });

              const colorsToRemove = [];
              if (removeBg) {
                  colorsToRemove.push(keyColor);
                  if (enableSecondColor) {
                      colorsToRemove.push(keyColor2);
                  }
              }

              for (let i = 0; i < totalFrames; i++) {
                if (!videoRef.current) break;

                const time = interval * (i + 1);
                await seekToTime(video, time);

                tempCtx.clearRect(0, 0, frameWidth, frameHeight);
                if (video.readyState >= 2) {
                    tempCtx.drawImage(video, 0, 0, videoMeta.width, videoMeta.height, 0, 0, frameWidth, frameHeight);
                }

                if (removeBg) {
                    // 传入 protectBody 参数
                    applyChromaKey(tempCtx, frameWidth, frameHeight, colorsToRemove, tolerance, protectBody);
                }

                let dx = 0, dy = 0;
                if (outputMode === 'sprite') {
                    const cols = parseInt(columns);
                    dx = (i % cols) * frameWidth;
                    dy = Math.floor(i / cols) * frameHeight;
                } else {
                    ctx.clearRect(0, 0, frameWidth, frameHeight);
                    dx = 0; 
                    dy = 0;
                }

                ctx.drawImage(tempCanvas, 0, 0, frameWidth, frameHeight, dx, dy, frameWidth, frameHeight);
                
                if (gif) {
                    gif.addFrame(ctx, { copy: true, delay: delay, dispose: 2 });
                }
                
                setProgress(Math.round(((i + 1) / totalFrames) * 90)); 
              }

              if (outputMode === 'sprite') {
                  try {
                      const dataUrl = canvas.toDataURL('image/png');
                      setGeneratedImage(dataUrl);
                      setProgress(100);
                  } catch (e) {
                      console.error(e);
                      throw new Error("导出图片失败，可能是浏览器跨域限制。");
                  }
              } else if (gif) {
                  setProgress(95);
                  gif.on('finished', function(blob) {
                      const gifUrl = URL.createObjectURL(blob);
                      setGeneratedImage(gifUrl);
                      setProgress(100);
                  });
                  gif.render();
              }

            } catch (err) {
              console.error(err);
              setError(err.message || "生成失败");
            } finally {
              if (outputMode === 'sprite') setIsProcessing(false);
            }
          };

          useEffect(() => {
              if (progress === 100) {
                  setIsProcessing(false);
              }
          }, [progress]);

          const downloadImage = () => {
            if (generatedImage) {
              const link = document.createElement('a');
              link.href = generatedImage;
              link.download = outputMode === 'sprite' 
                ? `sprite-${Date.now()}.png` 
                : `animation-${Date.now()}.gif`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            }
          };

          const formatTime = (seconds) => {
            if (!seconds) return "0:00";
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
          };

          const estimatedW = Math.round(videoMeta.width * scale * (outputMode === 'sprite' ? columns : 1));
          const estimatedH = Math.round(videoMeta.height * scale * (outputMode === 'sprite' ? Math.ceil(frameCount / columns) : 1));

          return (
            <div className="min-h-screen bg-gray-900 text-gray-100 font-sans p-4 md:p-8">
              <div className="max-w-6xl mx-auto space-y-8">
                
                <header className="flex flex-col md:flex-row items-center justify-between border-b border-gray-800 pb-6">
                  <div className="flex items-center space-x-3 mb-4 md:mb-0">
                    <div className="p-3 bg-indigo-600 rounded-lg shadow-lg shadow-indigo-500/20">
                      <FilmIcon className="w-8 h-8 text-white" />
                    </div>
                    <div>
                      <h1 className="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-indigo-400 to-cyan-400">
                        视频转 GIF/精灵图
                      </h1>
                      <p className="text-gray-400 text-sm">支持透明背景视频，一键生成 GIF 或 Sprite</p>
                    </div>
                  </div>
                </header>

                <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                  
                  <div className="lg:col-span-1 space-y-6">
                    
                    <div 
                      className={`border-2 border-dashed rounded-xl p-8 text-center transition-colors cursor-pointer group ${videoUrl ? 'border-green-500/50 bg-green-500/5' : 'border-gray-700 hover:border-indigo-500 hover:bg-gray-800'}`}
                      onClick={() => fileInputRef.current.click()}
                    >
                      <input 
                        type="file" 
                        ref={fileInputRef} 
                        accept="video/*" 
                        className="hidden" 
                        onChange={handleFileChange} 
                      />
                      {videoUrl ? (
                         <div className="flex flex-col items-center text-green-400">
                            <FilmIcon className="w-10 h-10 mb-2" />
                            <span className="font-medium">视频已加载</span>
                            <span className="text-xs text-gray-400 mt-1">点击更换视频</span>
                         </div>
                      ) : (
                        <div className="flex flex-col items-center text-gray-400 group-hover:text-indigo-400">
                          <UploadIcon className="w-10 h-10 mb-2" />
                          <span className="font-medium">点击上传视频</span>
                          <span className="text-xs text-gray-500 mt-1">支持 MP4, WebM, MOV</span>
                        </div>
                      )}
                    </div>

                    <video 
                      ref={videoRef} 
                      src={videoUrl} 
                      onLoadedMetadata={handleLoadedMetadata} 
                      className="video-hidden" 
                      muted
                      playsInline
                      preload="auto"
                    />

                    <div className="bg-gray-800 rounded-xl p-6 border border-gray-700 space-y-6">
                      <div className="flex items-center space-x-2 text-lg font-semibold text-white mb-2">
                        <SettingsIcon className="w-5 h-5 text-indigo-400" />
                        <span>生成设置</span>
                      </div>

                      {/* 模式选择 */}
                      <div className="bg-gray-900 p-1 rounded-lg flex space-x-1">
                          <button 
                            onClick={() => setOutputMode('sprite')}
                            className={`flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all ${outputMode === 'sprite' ? 'bg-indigo-600 text-white shadow' : 'text-gray-400 hover:text-white'}`}
                          >
                            PNG 精灵图
                          </button>
                          <button 
                            onClick={() => setOutputMode('gif')}
                            className={`flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all ${outputMode === 'gif' ? 'bg-indigo-600 text-white shadow' : 'text-gray-400 hover:text-white'}`}
                          >
                            GIF 动图
                          </button>
                      </div>

                      {/* 基础参数 */}
                      <div className="space-y-4">
                        <div>
                            <div className="flex justify-between mb-2">
                              <label className="text-sm text-gray-300">提取帧数</label>
                              <span className="text-sm font-mono text-indigo-400">{frameCount}</span>
                            </div>
                            <input 
                              type="range" 
                              min="1" 
                              max="300" 
                              step="1"
                              value={frameCount} 
                              onChange={(e) => setFrameCount(Number(e.target.value))} 
                              className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-indigo-500"
                            />
                        </div>

                        <div>
                            <div className="flex justify-between mb-2">
                              <label className="text-sm text-gray-300">图片缩放</label>
                              <span className="text-sm font-mono text-indigo-400">{Math.round(scale * 100)}%</span>
                            </div>
                            <input 
                              type="range" 
                              min="0.05" 
                              max="1.0" 
                              step="0.05"
                              value={scale} 
                              onChange={(e) => setScale(Number(e.target.value))} 
                              className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-indigo-500"
                            />
                        </div>

                        {outputMode === 'sprite' && (
                          <div>
                            <div className="flex justify-between mb-2">
                              <label className="text-sm text-gray-300">每行列数</label>
                              <span className="text-sm font-mono text-indigo-400">{columns}</span>
                            </div>
                            <input 
                              type="range" 
                              min="1" 
                              max={frameCount} 
                              step="1"
                              value={columns} 
                              onChange={(e) => setColumns(Number(e.target.value))} 
                              className="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-indigo-500"
                            />
                          </div>
                        )}
                      </div>

                      {/* 抠图设置面板 */}
                      <div className="pt-4 border-t border-gray-700">
                          <button 
                            onClick={() => setRemoveBg(!removeBg)}
                            className="flex items-center space-x-2 text-sm font-medium text-gray-300 hover:text-white transition-colors mb-4 w-full"
                          >
                             <div className={`w-4 h-4 rounded border ${removeBg ? 'bg-indigo-500 border-indigo-500' : 'border-gray-500'} flex items-center justify-center`}>
                                {removeBg && <svg className="w-3 h-3 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3"><polyline points="20 6 9 17 4 12"/></svg>}
                             </div>
                             <span className="flex items-center">
                                <WandIcon className="w-4 h-4 mr-1.5" />
                                启用背景移除 (抠图)
                             </span>
                          </button>

                          {removeBg && (
                              <div className="space-y-4 bg-gray-900/50 p-4 rounded-lg border border-gray-700 animate-in fade-in slide-in-from-top-2 duration-200">
                                  
                                  {/* 预设按钮 */}
                                  <button 
                                      onClick={applyCheckerboardPreset}
                                      className="w-full py-2 bg-gray-700 hover:bg-gray-600 text-xs text-white rounded flex items-center justify-center space-x-2 border border-gray-600 mb-2 transition-colors"
                                  >
                                      <GridIcon className="w-3 h-3 text-gray-300" />
                                      <span>一键应用：去除灰白棋盘格</span>
                                  </button>

                                  <div className="flex items-center justify-between">
                                      <label className="text-xs text-gray-400">主要颜色</label>
                                      <div className="flex items-center space-x-2">
                                          <span className="text-xs font-mono text-gray-500">{keyColor}</span>
                                          <input 
                                            type="color" 
                                            value={keyColor}
                                            onChange={(e) => setKeyColor(e.target.value)}
                                            className="border-0 p-0 rounded-full w-8 h-8 cursor-pointer ring-2 ring-gray-700 hover:ring-indigo-500 transition-all"
                                          />
                                      </div>
                                  </div>

                                  <div className="flex items-center justify-between pt-2 border-t border-gray-800">
                                      <div className="flex items-center space-x-2">
                                          <input 
                                            type="checkbox" 
                                            id="enableSecond"
                                            checked={enableSecondColor}
                                            onChange={(e) => setEnableSecondColor(e.target.checked)}
                                            className="rounded border-gray-600 bg-gray-700 text-indigo-500 focus:ring-indigo-500"
                                          />
                                          <label htmlFor="enableSecond" className="text-xs text-gray-400 select-none cursor-pointer">启用第二种颜色</label>
                                      </div>
                                      
                                      {enableSecondColor && (
                                          <div className="flex items-center space-x-2">
                                              <span className="text-xs font-mono text-gray-500">{keyColor2}</span>
                                              <input 
                                                type="color" 
                                                value={keyColor2}
                                                onChange={(e) => setKeyColor2(e.target.value)}
                                                className="border-0 p-0 rounded-full w-8 h-8 cursor-pointer ring-2 ring-gray-700 hover:ring-indigo-500 transition-all"
                                              />
                                          </div>
                                      )}
                                  </div>
                                  
                                  <div>
                                      <div className="flex justify-between mb-1">
                                        <label className="text-xs text-gray-400">颜色容差 (相似度)</label>
                                        <span className="text-xs font-mono text-indigo-400">{tolerance}</span>
                                      </div>
                                      <input 
                                        type="range" 
                                        min="1" 
                                        max="440" 
                                        step="1"
                                        value={tolerance} 
                                        onChange={(e) => setTolerance(Number(e.target.value))} 
                                        className="w-full h-1.5 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-indigo-500"
                                      />
                                  </div>

                                  {/* 保护人物内部开关 */}
                                  <div className="pt-2 border-t border-gray-800">
                                      <div className="flex items-center justify-between">
                                          <div className="flex items-center space-x-2 text-gray-300">
                                            <ShieldIcon className="w-4 h-4 text-green-400" />
                                            <span className="text-xs font-medium">只移除边缘背景 (保护人物)</span>
                                          </div>
                                          <div 
                                            className={`w-10 h-5 flex items-center bg-gray-700 rounded-full p-1 cursor-pointer transition-colors ${protectBody ? 'bg-green-600' : ''}`}
                                            onClick={() => setProtectBody(!protectBody)}
                                          >
                                            <div className={`bg-white w-3 h-3 rounded-full shadow-md transform transition-transform ${protectBody ? 'translate-x-5' : ''}`}></div>
                                          </div>
                                      </div>
                                      <p className="text-[10px] text-gray-500 mt-1 pl-6">
                                        开启后，仅移除与画面边缘连通的背景色，人物内部的相同颜色（如白衬衫、灰发）会被保留。
                                      </p>
                                  </div>
                              </div>
                          )}
                      </div>

                      {videoUrl && (
                        <div className="p-3 rounded text-xs space-y-1 bg-gray-900 border-transparent text-gray-400">
                          <div className="flex justify-between">
                            <span>原视频时长:</span>
                            <span>{formatTime(videoMeta.duration)}</span>
                          </div>
                          <div className="flex justify-between pt-1">
                            <span>{outputMode === 'sprite' ? '预计大图尺寸' : 'GIF 尺寸'}:</span>
                            <span className="font-mono text-indigo-300">
                              {estimatedW} x {estimatedH} px
                            </span>
                          </div>
                        </div>
                      )}

                      <button 
                        onClick={generate}
                        disabled={!videoUrl || isProcessing}
                        className={`w-full py-3 px-4 rounded-lg font-bold text-white transition-all flex items-center justify-center space-x-2
                          ${!videoUrl 
                            ? 'bg-gray-700 cursor-not-allowed text-gray-500' 
                            : isProcessing 
                              ? 'bg-indigo-700 cursor-wait opacity-80' 
                              : 'bg-indigo-600 hover:bg-indigo-500 hover:shadow-lg hover:shadow-indigo-500/25 active:transform active:scale-95'
                          }`}
                      >
                        {isProcessing ? (
                          <>
                            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
                            <span>
                                {progress < 100 ? `处理中 ${progress}%` : '最终渲染中...'}
                            </span>
                          </>
                        ) : (
                          <>
                            <ImageIcon className="w-5 h-5" />
                            <span>{outputMode === 'sprite' ? '生成精灵图' : '生成 GIF 动图'}</span>
                          </>
                        )}
                      </button>
                    </div>
                  </div>

                  <div className="lg:col-span-2 bg-gray-800 rounded-xl border border-gray-700 p-1 overflow-hidden flex flex-col h-[600px] lg:h-auto">
                     <div className="bg-gray-900 border-b border-gray-700 p-3 flex justify-between items-center">
                        <h2 className="text-sm font-medium text-gray-300">
                            预览结果 ({outputMode === 'sprite' ? 'PNG' : 'GIF'})
                        </h2>
                        {generatedImage && (
                          <button 
                            onClick={downloadImage}
                            className="bg-green-600 hover:bg-green-500 text-white text-xs px-3 py-1.5 rounded flex items-center space-x-1 transition-colors"
                          >
                            <DownloadIcon className="w-3 h-3" />
                            <span>下载 {outputMode === 'sprite' ? 'PNG' : 'GIF'}</span>
                          </button>
                        )}
                     </div>

                     <div className="flex-1 overflow-auto bg-gray-900/50 p-4 relative flex items-center justify-center custom-scrollbar">
                        <canvas ref={canvasRef} className="hidden" />

                        {error && (
                          <div className="text-red-400 flex flex-col items-center text-center max-w-md p-4 bg-red-900/20 rounded-lg border border-red-500/30">
                            <AlertCircleIcon className="w-8 h-8 mb-2" />
                            <p className="font-medium">出错了</p>
                            <p className="text-sm opacity-80 mt-1">{error}</p>
                          </div>
                        )}

                        {!generatedImage && !isProcessing && !error && (
                           <div className="text-gray-600 flex flex-col items-center">
                              <div className="w-16 h-16 border-2 border-dashed border-gray-700 rounded-lg mb-2 flex items-center justify-center">
                                <ImageIcon className="w-6 h-6" />
                              </div>
                              <p className="text-sm">预览将显示在这里</p>
                           </div>
                        )}

                        {isProcessing && (
                          <div className="absolute inset-0 flex flex-col items-center justify-center bg-gray-900/80 z-10 backdrop-blur-sm">
                             <div className="w-64 h-4 bg-gray-700 rounded-full overflow-hidden mb-2">
                                <div 
                                  className="h-full bg-indigo-500 transition-all duration-300 ease-out"
                                  style={{ width: `${progress}%` }}
                                ></div>
                             </div>
                             <p className="text-indigo-300 text-sm font-mono animate-pulse">
                                {outputMode === 'gif' && progress > 90 ? '正在编码 GIF (可能需要几秒)...' : `正在提取帧: ${progress}%`}
                             </p>
                          </div>
                        )}
                        
                        {generatedImage && (
                          <img 
                            src={generatedImage} 
                            alt="Generated Output" 
                            className="max-w-none shadow-2xl border border-gray-700 bg-[url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMUlEQVQ4T2NkYGAQYcAP3uCTZhw1gGGYhAGBZIA/nYDCgBDAm9BGDWCEAvgUGjZGYwIAxuoHr4hHvAQAAAAASUVORK5CYII=')] bg-repeat" 
                            /* 上面加了一个棋盘格背景，方便看透明效果 */
                          />
                        )}
                     </div>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
